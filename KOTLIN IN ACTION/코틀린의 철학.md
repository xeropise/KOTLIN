## 코틀린의 철학

### 실용성

- 실제 문제를 해결하기 위해 만들어진 실용적인 언어, 코틀린은 연구를 위한 언어가 아니라 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존한다. 
 
- 이로 인해 언어의 복잡도가 줄어들고 이미 알고 있는 기존 개념을 통해 코틀린을 더 쉽게 배울 수 있다.

- 특정 프로그램이 스타일이 패러다임을 사용할 것을 강제로 요구하지 않는다.

- 코틀린 언어의 특성을 항상 도구의 활용을 염두해 두고 설계되어 있다. 코틀린 언어를 지원하는 IDE는 흔히 쓰이지만 더 간결한 구조로 바꿀 수 있는 대부분의 코드 패턴을 도구가 자동으로 감지해서 수정하라고 제안한다.

<br>

### 간결성

- 의도를 쉽게 파악할 수 있는 구문 구조를 제공하고, 방해가 도리 수 있는 부가적인 준비 코드가 적다. 

  - 별뜻은 없지만 언어가 요구하는 구조를 만족시키기 위해 프로그램에 꼭 넣어야 하는 부수적인 요소를 줄이기 위해 많은 노력을 기울였다.
  
  - 게터, 세터, 생성자 파라미터를 필드에 대입하기 위한 로직 등 자바에 존재하는 여러 가지 번거로운 준비 코드를 코틀린은 묵시적으로 제공한다. 

  - 컬렉션에서 원소를 찾는 것과 같은 일반적입 작업을 수행하기 위해 명시적으로 작성해야만 하는 코드의 양이 상당하기 때문인데 코틀린은 기능이 다양한 표준 라이브러리르 제공하기 떄문에 반복되거나
  길어질 수 있는 코드를 라이브러리 함수 호출로 대치할 수 있다.
  
  - 코틀린은 람다를 지원하기 때문에 작은 코드 블록을 라이브러리 함수에 쉽게 전달할 수 있다. 따라서 일반적인 긴으을 라이브러리 안에 캡슐화하고 작업에 따라 달려쟈아 하는 개별적인 내용을 사용자가 작성한 코드 안에 남겨둘 수 있다. 

- 코틀린 설계 목표는 소스코드를 가능한 짧게 만든다는 내용을 들어있지 않다. 

  - 연산자 오버로딩(operator overloading)을 지원하지만, 언어가 제공하지 않는 연산자를 프로그래머가 정의할 수 있게 허용하지 않는다.

<br>

### 안전성

- 자바보다 더 높은 수준의 안전성을 달성하되 전체 비용은 더 적게 지불하고 싶어한다. 

  - JVM에서 실행하여 메모리 안전성을 보장하고, [버퍼 오버플로우](https://ko.wikipedia.org/wiki/%EB%B2%84%ED%8D%BC_%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C) 등 동적으로 할당한 메모리를 잘못 사용함으로 인해 발생할 수 있는 문제들을 예방할 수 있다.

  - JVM에서 실행되는 정적 타입 지정 언어로서 애플리케이션의 타입 안정성을 보장한다. 하지만 자바보다 더 적은 비용으로 타입 안전성을 사용할 수 있다. 

  - 코틀린 컴파일러가 타입을 자동으로 추론해주기 때문에 직접 타입 정보를 지정할 필요가 없다. 

  - 실행 시점에 오류를 발생시키는 대신 컴파일 시점 검사를 통해 오류를 더 많이 방지해 준다.

  - 프로그램의 NullPointerException 을 없애기 위해 노력한다.
