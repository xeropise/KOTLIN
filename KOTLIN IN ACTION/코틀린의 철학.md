## 코틀린의 철학

### 실용성

- 실제 문제를 해결하기 위해 만들어진 실용적인 언어, 코틀린은 연구를 위한 언어가 아니라 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존한다. 
 
- 이로 인해 언어의 복잡도가 줄어들고 이미 알고 있는 기존 개념을 통해 코틀린을 더 쉽게 배울 수 있다.

- 특정 프로그램이 스타일이 패러다임을 사용할 것을 강제로 요구하지 않는다.

- 코틀린 언어의 특성을 항상 도구의 활용을 염두해 두고 설계되어 있다. 코틀린 언어를 지원하는 IDE는 흔히 쓰이지만 더 간결한 구조로 바꿀 수 있는 대부분의 코드 패턴을 도구가 자동으로 감지해서 수정하라고 제안한다.

<br>

### 간결성

- 의도를 쉽게 파악할 수 있는 구문 구조를 제공하고, 방해가 도리 수 있는 부가적인 준비 코드가 적다. 

  - 별뜻은 없지만 언어가 요구하는 구조를 만족시키기 위해 프로그램에 꼭 넣어야 하는 부수적인 요소를 줄이기 위해 많은 노력을 기울였다.
  
  - 게터, 세터, 생성자 파라미터를 필드에 대입하기 위한 로직 등 자바에 존재하는 여러 가지 번거로운 준비 코드를 코틀린은 묵시적으로 제공한다. 

  - 컬렉션에서 원소를 찾는 것과 같은 일반적입 작업을 수행하기 위해 명시적으로 작성해야만 하는 코드의 양이 상당하기 때문인데 코틀린은 기능이 다양한 표준 라이브러리르 제공하기 떄문에 반복되거나
  길어질 수 있는 코드를 라이브러리 함수 호출로 대치할 수 있다.
  
  - 코틀린은 람다를 지원하기 때문에 작은 코드 블록을 라이브러리 함수에 쉽게 전달할 수 있다. 따라서 일반적인 긴으을 라이브러리 안에 캡슐화하고 작업에 따라 달려쟈아 하는 개별적인 내용을 사용자가 작성한 코드 안에 남겨둘 수 있다. 

- 코틀린 설계 목표는 소스코드를 가능한 짧게 만든다는 내용을 들어있지 않다. 

  - 연산자 오버로딩(operator overloading)을 지원하지만, 언어가 제공하지 않는 연산자를 프로그래머가 정의할 수 있게 허용하지 않는다.

<br>

### 안전성

- 자바보다 더 높은 수준의 안전성을 달성하되 전체 비용은 더 적게 지불하고 싶어한다. 

  - JVM에서 실행하여 메모리 안전성을 보장하고, [버퍼 오버플로우](https://ko.wikipedia.org/wiki/%EB%B2%84%ED%8D%BC_%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C) 등 동적으로 할당한 메모리를 잘못 사용함으로 인해 발생할 수 있는 문제들을 예방할 수 있다.

  - JVM에서 실행되는 정적 타입 지정 언어로서 애플리케이션의 타입 안정성을 보장한다. 하지만 자바보다 더 적은 비용으로 타입 안전성을 사용할 수 있다. 

  - 코틀린 컴파일러가 타입을 자동으로 추론해주기 때문에 직접 타입 정보를 지정할 필요가 없다. 

  - 실행 시점에 오류를 발생시키는 대신 컴파일 시점 검사를 통해 오류를 더 많이 방지해 준다.

  - 프로그램의 NullPointerException 을 없애기 위해 노력한다. 코틀린의 타입 시스템은 null이 될 수 없는 값을 추척하며, 실행 시점에 NullPointerException 이 발생할 수 있는 연산을 사용하는 코드를 금지한다. ( ? 한글자로 널이 될 수 있는 여부 표시 가능 )

  - 널이 될 수 있는 값을 다룰 수 있는 편리한 방법을 다양하게 제공한다.

  - 어떤 객체를 다른 타입으로 캐스트(cast) 하기 전에 타입을 미리 검사 하지 않으면 ClassCastException 이 발생하는데 코틀린에서는 타입 검사와 캐스트가 한 연산자에 의해 이뤄진다. 어떤 객체의 타입을 검사했고 그 객체가 그 타입에 속한다며 해당 타입의 메소드나 필드 등의 멤버를 별도의 캐스트 없이 사용할 수 있다.

 - 따라서 타입 검사를 생략할 ㅇ유가 없고, 검사를 생략 하지 않으면 검사를 생략해서 생기는 오류가 발생할 일도 없다.

 ```kotlin
 if (value is String) // 타입을 검사
  println(value.toUpperCase()) // 해당 타입의 메소드를 사용
 ```
 
 <br>
 
 ### 상호운용성(interoperability)
 
 - 기존 자바 라이브러리를 그대로 사용할 수 있다. 자바 메소드를 호출하거나 자바 클래스를 상속하거나 인터페이스를 구현하거나 자바 애노테이션을 코틀린 코드에 적용하는 등의 일이 모두 가능하다.

 - 자바 코드에서 코틀린을 호출할 때도 아무런 노력이 필요 없다. 코틀린의 클래스나 메솓를 일반적인 자바 클래스나 메소드와 똑같이 사용할 수 있다. 자바와 코틀린 코드를 프로젝트에서 원하는 대로 섞어 쓸 수 있는 궁극적인 유연성을 발휘할 수 있다.

- 기존 자바 프로젝트에 코틀린을 도입하는 경우, 자바를 코틀린으로 변환하는 도구를 코드베이스 안에 있는 자바 클래스에 대해 실행해서 그 클래스를 코틀린 클래스로 변환할 수 있다.
