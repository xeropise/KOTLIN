- 변성(variance) 개념은 List<String> 과 List<Any> 와 같이 기저 타입이 같고, 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다

  

- 직접 제네릭 클래스나 함수를 정의하는 경우, 변성을 꼭 이해해야 한다.

  - 변성을 잘 활용하면 사용에 불편하지 않으면서 타입 안전성을 보장하는 API를 만들 수 있다.



<br>



***

### 변성이 있는 이유 : 인자를 함수에 넘기기

- List<Any> 타입의 파라미터를 받는 함수에 List<String> 을 넘기면 과연 안전할까?



```kotlin
fun printContents(list: List<Any>) {
    println(list.joinToString())
}

printContents(listOf("abc","bac"))  // abc, bac
```

> 위의 경우는 안전하게 동작한다.



<br>



```kotlin
fun addAnswer(list: MutableList<Any>) {
    list.add(42)
}

val strings = mutableListOf("abc", "bac")
addAnswer(strings)
println(strings.maxBy { it.length })
// ClassCastException: Integer cannot be cast to String
```



- 타입의 파라미터를 받는 함수에 원소를 추가하거나 변경한다면?

  - 타입의 불일치가 생길 수 있어서 어렵다.

    

- 코틀린에서는 List의 변경 가능성에 따라 적절한 인터페이스를 선택하면 안전하지 못한 함수 호출을 막을 수 있다.

  - 함수가 읽기 전용 리스트를 받는다면? 구체적인 타입 원소를 갖는 리스트를 그 함수에 넘길 수 있다.
  - 리스트가 변경 가능하다면? 그럴 수 없다.



<br>

***

### 클래스, 타입, 하위 타입

- 타입과 클래스의 차이에 대해 알아보자.

  - 제네릭 클래스가 아닌 클래스에서는 클래스 이름을 바로 타입으로 쓸 수 있다

  ```kotlin
  var x : String	
  
  var x : String?   // String, Null 타입을 포함하고 있다. 이는 모든 코틀린 클래스가 적어도 둘 이상의 타입을 구성할 수 있다는 말이다.
  ```

  <br>

  

  - 제네릭 클래스의 경우, 상황이 더 복잡하다. 올바른 타입을 얻으려면, 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.

  ```kotlin
  List<T>
  
  List<Int>
  List<String?>
  List<List<String>>
  
  // 각각의 제네릭 클래스는 무수히 많은 타입을 만들어 낼 수 있다.
  ```

  

- 타입 사이의 관계를 논하기 위해서는 하위 타입(subtype) 개념을 잘 알아야 한다.

  - 어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없다면? 

    - 타입 B는 타입 A의 하위 타입이다.

      

- 상위 타입(supertype)은 하위 타입의 반대다.

  - A 타입이 B 타입의 하위 타입이라면 B는 A의 상위 타입이다.



- 한 타입이 다른 타입의 하위 타입인지가 왜 중요할까?

  - 컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행한다.

  ```kotlin
  fun test(i: Int) {
      val n: Number = i  // Int가 Number 의 하위 타입이어서 컴파일 된다.
      
      fun f(s: String) { ... }  // Int가 String의 하위 타입이 아니여서, 컴파일되지 않는다.
      f(i)
  }
  ```

  

- 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다.

  - A? <- A

    

  - 두 타입 모두 같은 클래스이다. 

    

  - 항상 널이 될 수 없는 타입의 값을 널이 될 수 있는 타입의 변수에 저장할 수 있지만, 거꾸로 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 변수에 저장할 수는 없다.

  ```kotlin
  val s: String = "abc"
  val t: String? = s
  ```

  

- List<Any> 타입의 파라미터를 받는 함수에 List<String> 을 넘기면 과연 안전할까?

  - List<String>은 List<Any>의 하위 타입인가 와 같은 말이다.

    

- 제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가면 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않으면?

  - 그 제네릭 타입을 무공변(invariant) 라고 말한다.



<br>

***

### 공변성: 하위 타입 관계를 유지

- Producer<T> 로 공변성 클래스를 설명해 보자.

  - A가 B의 하위 타입일 때, Producer<A>가, Producer<B> 의 하위 타입이면 Producer는 공변적이다.

  - 하위 타입 관계가 유지된다고 말한다.

    

- Cat은 Animal의 하위 타입이므로, Producer<Cat> 은 Producer<Animal> 의 하위 타입이다.



- 코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면?
  - 타입 파라미터 이름 앞에 out 을 넣어야 한다.

```kotlin
inteface Producer<out T> {  // 클래스가 T에 대해 공변적이라고 선언
    fun produce() : T
}
```



- 클래스의 타입 파라미터를 공변적으로 만들면 어떻게 될까
  - 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도, 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.



> 무공변 컬렉션 역할을 하는 클래스 정의하기

```kotlin
open class Animal {
    fun feed() { ... }
}

class Herd<T: Animal> {	// 이 타입 파라미터를 무공변성으로 지정한다.
    val size: Int get() = ...
    operator fun get(i: Int) : T { ... }
}

fun feedAll(animals: Herd<Animal>) {
    for (i in 0 untill animals.size) {
        animals[i].feed()
    }
}
```



>  무공변 컬렉션 역할을 하는 클래스 사용하기

```kotlin
class Cat : Animal() {
    fun cleanLitter() { ... }
}

fun takeCareOfCats(cats: Herd<Cat>) {
    for (i in 0 until cats.size) {
        cats[i].cleanLitter()
        // feedAll(cats)   // Error: inferred type is Herd<Cat>, but Herd<Animal> was expected 라는 오류가 발생
    }
}
```



- Herd 클래스의 T 타입 파라미터에 대해 아무 변성도 지정하지 않았기 때문에, Herd<Cat> 은 Herd<Animal> 의 하위 클래스가 아니다.

  

- 명시적으로 타입 캐스팅을 사용하면 문제 해결이 가능하나 그런식으로 처리하면 코드가 장황해지고 실수를 하기 쉽다.

  

- 타입 불일치를 해결하기 위해, 강제 캐스팅을 하는 것은 결코 올바른 방법이 아니다.

  

- Herd 를 공변적인 클래스를 만들기 위해 다음과 같이 바꿔야 한다.

```kotlin
class Herd<out T : Animal> {   // T 는 이제 공변적이다. 
    ...
}

fun takeCarOfCats(cats: Herd<Cat>) {
    for ( i in 0 until cats.size) {
        cats[i].cleanLitter()
    }
    feedAll(cats)			// 캐스팅을 할 필요가 없다.
}
```



- 모든 클래스를 공변적으로 만들 수는 없다. 공변적으로 만들면 안전하지 못한 클래스도 있다.

  

- 타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다.

  

- 타입 안전성을 보장하기 위해, 공변적 파라미터는 항상 out 위치에 있어야 한다.

  - 클래스가 T 타입의 값을 생산할 수는 있지만, T 타입의 값을 소비할 수는 없다는 말이다.

    

- 함수 파라미터 타입은 인 위치, 함수 반환 타입은 아웃 위치에 있다.

```kotlin
interface Transformer<T> {
    fun transform(t: T) : T
    		// 인 위치,   아웃 위치	
}
```



- 클래스 타입 파라미터 T 앞에 out 키워드를 붙이면, 클래스 안에서 T를 사용하는 메소드가 아웃 위치에서만 T를 사용하게 허용하고, 인 위치에서는 T를 사용하지 못하게 막는다.
  - out 키워드는 T의 사용법을 제한하며, T로 인해 생기는 하위 타입 관계의 타입 안전성을 보장한다.