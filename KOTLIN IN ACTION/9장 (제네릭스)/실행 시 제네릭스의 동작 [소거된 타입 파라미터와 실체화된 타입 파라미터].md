- JVM의 제네릭스는 보통 타입 소거(type erasure)를 사용해 구현된다.
  - 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻



***

### 실행 시점의 제네릭: 타입 검사와 캐스트

- 자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.
  - 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인 타입 인자에 대한 정보를 유지하지 않는다는 뜻



```kotlin
val list1: List<String> = listOf("a", "b")  
val list2: List<Int> = listOf(1 , 2, 3)		// 각 객체는 단지 List 이다.
```



- 컴파일러는 두 리스트를 서로 다른 타입으로 인식하지만, 실행 시점에 그 둘은 완전히 같은 타입의 객체이다.

  

- 컴파일러가 타입 인자를 알고 올바른 타입의 값만 각 리스트에 넣도록 보장해 준다. 



- 타입 소거로 인해 생기는 한계는 다음과 같다.

  - 타입 인자를 따로 저장하지 않기 때문에 실행 시점에 타입 인자를 검사할 수 없다.

  - 일반적으로 말하면 is 검사에서 타입 인자로 지정한 타입을 검사할 수 없다.

    

>  List가 String 인지 Person 인지는 지워져서 알 수 없지만, 저장해야 하는 타입 정보 크기가 줄어들어 전반적인 메모리 사용량이 줄어든다는 장점이 있긴 하다.



```kotlin
if (value is List<String>) { ... }
// Error: Cannot check for instance of erased type
```



<br>



- 코틀린에서는 타입 인자를 명시하지 않고, 제네릭 타입을 사용할 수 없다.

  - 어떤 값이 집합이나 맵이 아니라 리스트라는 사실을 어떻게 확인할 수 있을까?

    - __스타 프로젝션(star projection)__ 을 사용하면 된다.

      

```kotlin
if (value is List<*>) { ... }
```



- 타입 파라미터가 2개 이상이라면 모든 타입 파라미터에 *를 포함시켜야 한다.

  - 인자를 알 수 없는, 제네릭 타입을 표현할 때 스타 프로젝션을 쓴다고만 알아 두자. ( 자바의 List<?> 와 비슷 )

    

- 실행 시점에 제네릭 타입의 타입 인자를 알 수 없으므로, 캐스팅은 항상 성공한다.

  - 그러한 타입 캐스팅을 사용하면 컴파일러가 'unchecked cast' 라는 경고를 한다.
  - 컴파일러는 단순히 경고만 하고 컴파일을 진행하므로, 원하는 제네릭 타입으로 캐스팅해 사용해도 된다.



```kotlin
fun printSum(c: Collection<*>) {
    val intList = c as? List<Int>   // 경고가 발생한다.
    	?: throw IllegalArgumentException("List is expected")
    println(intList.sum())
}

printSum(listOf(1, 2, 3)) // 예상대로 작동한다.
```



-  코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 is 검사를 수행하게 허용할 수 있다.

```kotlin
fun printSum(c: Collection<Int>) {
    if (c is List<Int>) { // 이 검사는 제대로 동작한다.
        println(c.sum())
    }
}
```

