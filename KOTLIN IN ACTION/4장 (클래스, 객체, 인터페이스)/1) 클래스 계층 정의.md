## 클래스 계층 정의

<br>

- 코틀린에서 클래스 계층을 정의하는 방식과 자바 방식을 비교해 보자. 그 후 코틀린의 가시성과 접근 변경자에 대해 살펴본다.

<br>

- 코틀린 가시성/접근 변경자는 자바와 비슷하지만 아무것도 지정하지 않은 경우, 기본 가시성과 다르다.

<br>

- 코틀린에 새로 도입한 sealed 변경자도 알아 보자. sealed 는 클래스 상속을 제한한다.

<br>

---

### 코틀린 인터페이스

- 인터페이스를 정의하고 구현하는 방법을 알아보자. 코틀린 인터페이스는 자바 8 인터페이스와 비슷하다.

<br>

- 코틀린 인터페이스 안에는 추상 메소드뿐 아니라 구현이 있는 메소드도 정의할 수 있다. (자바 8 default 메서드)

<br>

- 다만 인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.

<br>

- 코틀린에서 클래스는 class 로 정의하지만 인터페이스는 interface 를 사용한다.

<br>

```kotlin
interface Clickable{
    fun click()
}
```

<br>

- 이 인터페이스를 구현하는 모든 비추상 클래스(구체적 클래스)는 click 에 대한 구현을 제공해야 한다.

```kotlin
class Button : Clickable {
    override fun click() = println("I was clicked")
}

Button().click()
```

- 자바에서는 extends 와 implements 키워드를 사용하지만, 코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.

<br>

- 자바와 마찬가지로 클래스는 인터페이스를 원하는 만큼 개수 제한 없이 마음대로 구현할 수 있지만, 클래스는 오직 하나만 확장할 수 있다.

<br>

- @Override 애노테이션과 비슷한 override 변경자로 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드 할 수 있다.

<br>

- 자바와 달리 코틀린에서 override 변경자를 반드시 사용해야 한다. (실수로 상위 클래스의 메소드를 오버라이드 하는 경우를 방지해준다.)

<br>

- 인터페이스 메서드도 디폴트 구현을 제공할 수 있다. 그런 경우 메소드 앞에 default를 붙여야하는 자바와 달리 코틀린에서는 메소드를 특별한 키워드로 꾸밀 필요가 없다. (그냥 메소드 본문을 메소드 시그니처 뒤에 추가하면 된다.)

```kotlin
interface Clickable {
    fun click()
    func showOff() = println("I'm clickable")
}
```

<br>

- 위의 showOff 메소드를 정의하는 다른 인터페이스가 다음과 같은 구현을 포함한다고 하자.

```kotlin
interface Focusable {
    fun setFocus(b: Boolean) =
        println("I ${if (b) "got" else "lost"} focus.")
    fun showOff() = println("I'm focusable!")
}

```

<br>

- 한 클래스에서 이 두 인터페이스를 함께 구현하면 어느쪽도 선택되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 정의된 showOff 구현을 대체할 오버라이딩 메소드를 직접 제공하지 않으면 다음과 같은 컴파일러 오류가 발생한다.

```Error
The class 'Button' must
override public open fun showOff() becuase it inherits
many implementations of it.
```

<br>

- 코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

```Kotlin
class Button : Clickable, Focusable {
    override fun click() = println("I was clicked")

     // 상위 타입의 이름을 꺾쇠 괄호(<>) 사이에 넣어서 "super" 를 지정하면
     // 어떤 상위 타입의 멤버 메소드를 호출할지 지정할 수 있다.
    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }

    // 구체적으로 타입을 지정하는 문법이 다르다.
    // 자바에서는 Clickable.super.showOff() 처럼 super 앞에 기반 타입을 적지만
    // 코틀린에서는 super<Clickable>.showOff() 처럼 꺾쇠 괄호 안에 기반 타입의 이름을 지정한다.
}
```

<br>

- 코틀린은 자바 6와 호환되게 설계되었으므로 인터페이스의 디폴트 메서드를 지원하지 않는다. 코틀린은 디폴트 메서드가 있는 인터페이스를 일반 인터페이스와 디폴트 메소드 구현이 정적 메소드로 들어있는 클래스를 조합해 구현한다.

<br>

- 디폴트 인터페이스가 포함된 코틀린 인터페이스를 자바 클래스에서 상속해 구현하고 싶다면 코틀린에서 메소드 본문을 제공하는 메소드를 포함하는 모든 메소드에 대한 본문을 작성해야 한다. (즉 자바에서는 코틀린의 디폴트 메소드 구현에 의존할 수 없다.)

---

<br>

### open, final, abstract 변경자: 기본적으로 final

- 자바에서는 final로 명시적으로 상속을 금지하지 않는 모든 클래스를 다른 클래스가 상속할 수 있다.

<br>

- 이렇게 기본적으로 상속이 가능하면 편리한 경우도 많지만 문제가 생기는 경우도 많다.

<br>

- 어떤 클래스가 자신을 상속하는 방법에 대한 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 있다. (이펙티브 자바에 언급된 내용, 설계와 문서가 정확하지 않다면 상속을 못하게 막아라.)

<br>

- **자바의 클래스와 메소드는 기본적으로 상속에 대해 열려있지만, 코틀린의 클래스와 메소드는 기본적으로 final 이다.**

<br>

- 어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다. 그와 더불어 오버라이드를 허용하고 싶은 메소드나 프로퍼티의 앞에도 open 변경자를 붙여야 한다.

```kotlin
open class RichButton : Clickable { // 이 클래스는 열려있다. 다른 클래스가 이 클래스를 상속할 수 있다.
    fun disable() {}    // 이 함수는 final, 하위 클래스가 이 메소드를 오버라이드 할 수 없다.
    open fun animate() {}   // 이 함수는 열려 있다. 하위 클래스에서 이 메소드를 오버라이드해도 된다.
    override fun click() {} // 이 함수는 상위 클래스 메소드를 오버라이드 했다. 오버라이드 한 메소드는 기본적으로 열려 있다.
}
```

<br>

- **기반 클래스나 인터페이스의 멤버를 오버라이드 하는 경우, 그 메소드는 기본적으로 열려 있다.** 오버라이드 하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드 하는 메소드 앞에 final 을 명시해야 한다.

```kotlin
open class RichButton : Clickable {
    final override fun click() {}
}
```

<br>

---

> 열린 클래스와 스마트 캐스트

- 클래스의 기본적인 상속 가능 상태를 final 로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.

<br>

- 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능하다. 클래스 프로퍼티의 경우, 이는 val 이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트를 쓸 수 있다는 의미이다.

<br>

- 이 요구사항은 또한 프로퍼티가 final 이어야만 한다는 뜻이다. 프로퍼티가 final 이 아니라면 그 프로퍼티를 다른 클래스가 상속하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구 사항을 깰 수 있다.

<br>

- 프로퍼티는 기본적으로 final 이기 때문에 따로 고민할 필요 없이, 대부분의 프로퍼티를 스마트 캐스트에 활용할 수 있다.

<br>

---

<br>

- 자바처럼 코틀린에서도 클래스를 abstract 로 선언할 수 있다.

<br>

- abstract 로 선언한 추상 클래스는 인스턴스화할 수 없다.

<br>

- 추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드해야만 하는게 보통이다.

<br>

- 추상 멤버는 항상 열려있다. 따라서 추상 멤버 앞에 open 변경자를 명시할 필요가 없다.

<br>

```kotlin
abstract class Animated {

    abstract fun animate()

    //추상 클래스에 속했더라도 비추상 함수는 기본적으로 파이널이지만 원한다면 open 으로 오버라이드를 허용할 수 있다.
    open fun stopAnimating() {

    }

    fun animateTwice() {

    }
}
```

<br>

> 클래스 내에서 상속 제어 변경자의 의미

| 변경자   | 이 변경자가 붙은 멤버                                  | 설명                                                                                                    |
| -------- | ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------- |
| final    | 오버라이드 할 수 없음                                  | 클래스 멤버의 기본 변경자                                                                               |
| open     | 오버라이드 할 수 있음                                  | 반드시 open을 명시해야 오버라이드할 수 있다.                                                            |
| abstract | 반드시 오버라이드 해야 함                              | 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안 된다.                   |
| override | 상위 클래스나 상위 인스턴스의 멤버를 오버라이드하는 중 | 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다. |

<br>

---

<br>

### 가시성 변경자: 기본적으로 공개

- 가시성 변경자(visibility modifier)는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.

<br>

- 어떤 클래스의 구현에 대한 접근을 제한함으로써, 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있다.

<br>

- 코틀린 가시성 변경자는 자바와 비슷하다. 하지만 코틀린의 기본 가시성은 자바와 다르다. 아무 변경자도 없는 경우, 선언은 모두 공개(public)이 된다.

<br>

- 자바의 기본 가시성인 패키지 전용(default, package-private)는 코틀린에 없다. 코틀린은 패키지를 네임스페이스(namespace)를 관리하기 위한 용도로만 사용한다. 그래서 패키지를 가시성 제어에 사용하지 않는다.

<br>

- 패키지 전용 가시성에 대한 대안으로, 코틀린에는 internal 이라는 새로운 가시성 변경자를 도입했다. (모듈 내부), internal은 "모듈 내부에서만 볼 수 있음" 이라는 뜻이다.

<br>

- 모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다.
  (인텔리제이나 이클립스, 메이븐, 그레이들 등의 프로젝트가 모듈이 될 수도 있고, 앤트 태스크가 한 번 실행될 때 함께 컴파일되는 파일의 집합도 모듈이 될 수 있다.)
  
- 한 프로젝트라고 생각하면 된다.  
  

<br>

- 모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.

<br>

- 자바에서는 패키지가 같은 클래스를 선언하기만 하면 어떤 프로젝트의 외부에 있는 코드라도 패키지 내부에 있는 패키지 전용 선언에 쉽게 접근할 수 있다. 그래서 모듈의 캡슐화가 쉽게 깨진다.

<br>

- 코틀린에서는 최상위 선언(클래스, 함수, 프로퍼티)에 대해 private 가시성을 허용한다. 비공개 가시성인 최상위 선언은 그 선언이 들어있는 파일 내부에서만 사용할 수 있다.

<br>

| 변경자              | 클래스 멤버                      | 최상위 선언                    |
| ------------------- | -------------------------------- | ------------------------------ |
| public(기본 가시성) | 모든 곳에서 볼 수 있다.          | 모든 곳에서 볼 수 있다.        |
| internal            | 같은 모듈 안에서만 볼 수 있다.   | 같은 모듈 안에서만 볼 수 있다. |
| protected           | 하위 클래스 안에서만 볼 수 있다. | (최상위 선언에 적용할 수 없음) |
| private             | 같은 클래스 안에서만 볼 수 있다. | 같은 파일 안에서만 볼 수 있다. |

<br>

```kotlin
internal open class TalkativeButton : Focusable {
    private fun yell() = println("Hey!")
    protected fun whisper() = println("Let's talk!")
}

// 오류 "public" 멤버가 자신의 "internal" 수신 타입인 "TalkativeButton"을 노출
fun TalkativeButton.giveSpeech() {
    yell() // 오류 "yell"에 접근할 수 없음, "yell" 은 "TalkativeButton"의 "private" 멤버
    whisper()   // 오류 "whisper"에 접근할 수 없음: "whisper"는 "TalkativeButton"의 "private" 멤버임
}
```

<br>

- 어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 한다.

<br>

- 메소드 시그니처에 사용된 모든 타입의 가시성은 그 메소드의 가시성과 같거나 더 높아야 한다.

<br>

- 위의 경우 컴파일 오류를 없애려면 giveSpeech 확장 함수의 가시성을 internal 로 바꾸거나, TalkativeButton 클래스의 가시성을 public 으로 바꿔야 한다.

<br>

- 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린에서는 그렇지 않다는 점에서 자바와 코틀린의 protected 가 다르다.

<br>

- 코틀린의 가시성 규칙은 단순하다. protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.

<br>

- 클래스를 확장한 함수는 그 클래스의 private 나 protected 멤버에 접근할 수 없다.

<br>

---

> 코틀린의 가시성 변경자와 자바

- 코틀린의 public, protected, private 변경자는 컴파일된 자바 바이트코트 안에서도 그대로 유지된다.

<br>

- 그렇게 컴파일된 코틀린 선언의 가시성은 마치 자바에서 똑같은 가시성을 사용해 선언한 경우와 같다.

<br>

- 자바에서는 클래스를 private로 만들 수 없으므로, 내부적으로 코틀린은 private 클래스를 패키지-전용 클래스(default)로 컴파일한다.

<br>

- internal 변경자의 경우, 딱 맞는 가시성이 없으므로 바이트 코드상에서는 public 이 된다.

<br>

- 코틀린 선언과 그에 해당하는 자바 선언(또는 바이트코드 표현)에 차이가 있기 떄문에 코틀린에서는 접근할 수 없는 대상을 자바에서 접근할 수 있는 경우가 생긴다.

   <br>

  - 다른 모듈에 정의된 internal 클래스나 internal 최상위 선언을 모듈 외부의 자바 코드에서 접근할 수 있다.
  - protected 로 정의한 멤버를 코틀린 클래스와 같은 패키지에 속한 자바코드에서는 접근할 수 있다.

---

### 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스

- 코틀린과 자바 가시성 규칙의 또 다른 차이는 코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다는 점이다.
