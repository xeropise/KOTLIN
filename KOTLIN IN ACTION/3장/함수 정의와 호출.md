## 함수 정의와 호출

- 함수 정의와 호출 기능을 코틀린이 어떻게 개선했는지 살펴보자.



***

### 코틀린에서 컬렉션 만들기



```kotlin


fun main() {

    val set = hashSetOf(1, 7, 53)

    val list = arrayListOf(1, 7, 53)

    val map = hashMapOf(1 to "One", 7 to "seven", 53 to "fifty-three") // to가 키워드가 아니라 일반 함수

    // 만든 객체가 어떤 클래스에 속하는지 확인 가능
    println(set.javaClass) // class java.util.HashSet

    println(list.javaClass) // class java.util.ArrayList

    println(map.javaClass) // class java.util.HashMap

}

```



- 코틀린은 자체 컬렉션을 제공하지 않는 이유?
  - 표준 자바 컬렉션을 활용하면 자바 코드와 상호작용하기가 훨씬 더 쉽다. 
  - 자바에서 코틀린 함수를 호출하거나 코틀린에서 자바 함수를 호출할 때 자바와 코틀린 컬렉션을 서로 변환할 필요가 없다.

- 코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스 이다.
  - 하지만 코틀린에서 자바 보다 더 많은 기능을 쓸 수 있음

```kotlin
val strings = listOf("first", "second", "fourteeth")

println(strings.last()) // fourtetth

val numbers = setOf(1, 14, 2)

println(numbers.max()) // 14
```



***

### 함수를 호출하기 쉽게 만들기

- 함수를 직접 구현해 보자.

```kotlin
fun <T> joinToString(
    collection: Collection<T>,
    sepeartor: String,
    prefix: String,
    postfix: String
) : String {
    val result = StringBuilder(prefix)

    for ( (index, element) in collection.withIndex() ) {
        if (index > 0) result.append(sepeartor)
        result.append(element)
    }

    result.append(postfix)
    return result.toString()
}


fun main() {

    val list = listOf(1, 2, 3)

    println(joinToString(list, "; ", "(",")")) // 함수인자가 어디에 어떤 값이 들어 가는지 함수 시그니처를 보지 않는 이상 파악하기 어렵다. (가독성 문제)
  
  	println(joinToString(list, sepeartor = "", prefix = "", postfix = ", ")) // 코틀린에서는 이와 같은 방식으로 파라미터 이름을 명시할 수 있다.
 
}
```



- ### 디폴트 파라미터 값 

```kotlin
// 디폴트 파라미터 값을 사용해 위 함수 정의하기

fun <T> joinToString(
	collection: Collection<T>,
  seperator: String =", ", 		// 파라미터의 디폴트 값을 다음과 같이 설정 가능
  prefix: String= "",
  postfix: String= ""
) : String

fun main() {
  // 디폴트 파라미터 값을 통해 모든 인자를 쓸 수도, 일부를 생략할 수도 있다.
  list = arrayListOf("1", "2", "3")
  println(joinToString(list)) // 1, 2, 3
  println(joinToString(list, "; ")) // sepeartor 만 "; "로 지정, 나머지는 생략
  println(joinToString(list, postfix = "; ", prefix = "# "))
}
```



- 자바에서 디폴트 파라미터 값이라는 개념이 없으므로, 코틀린 함수를 자바에서 호출하는 경우, 그 코틀린 함수가 디폴트 파라미터 값을 제공하더라도 모든 인자를 명시해야 한다.

- 자바에서 코틀린 함수를 자주 호출해야 한다면 자바 쪽에서 좀 더 편하게 코틀린 함수를 호출하고 싶을 것이다.

- __그런 경우, @JvmOverloads 어노테이션을 함수에 추가 할 수 있는데, 코틀린 컴파일러가 자동으로 맨 마지막 파라미터로부터 파라미터를 하나씩 생략한 오버로딩한 자바 메소드를 추가해준다.__



```kotlin
// 디폴트 파라미터 값을 사용해 위 함수 정의하기
@JvmOverloads
fun <T> joinToString(
	collection: Collection<T>,
  seperator: String =", ", 		// 파라미터의 디폴트 값을 다음과 같이 설정 가능
  prefix: String= "",
  postfix: String= ""
) : String

fun main() {
  // 디폴트 파라미터 값을 통해 모든 인자를 쓸 수도, 일부를 생략할 수도 있다.
  list = arrayListOf("1", "2", "3")
  println(joinToString(list)) // 1, 2, 3
  println(joinToString(list, "; ")) // sepeartor 만 "; "로 지정, 나머지는 생략
  println(joinToString(list, postfix = "; ", prefix = "# "))
}

================

String joinToString(Collection<T> collection, String seperator, String prefix, String postfix); 
String joinToString(Collection<T> collection, String seperator, String prefix); 
String joinToString(Collection<T> collection, String seperator); 
String joinToString(Collection<T> collection);
                                   
```



- __정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티__

  - 자바는 모든 코드를 클래스의 메소드로 작성해야 한다는 문제 때문에 중요한 객체는 하나뿐이지만 그 연산을 객체의 인스턴스 API에 추가해서 만들어야 하는 경우가 생긴다.

  

  - JDK의 Collections 클래스가 전형적인 예이며, Util로 끝나는 이름의 클래스를 흔히 찾아 볼 수 있다.

  

  - 코틀린에서는 이런 무의미한 클래스는 필요가 없다.  함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다. (패키지 멤버 함수)

  

  - 다른 패키지에서 그 함수를 사용하고 싶을 때는 그 함수가 정의된 패키지를 임포트하면 된다. 임포트 시 유틸리티 클래스 이름이 추가로 들어갈 필요는 없다.

  

  ```kotlin
  package strings
  
  fun joinToString(...): String { ... }
  ```

  

  - 패키지 멤버 함수가 실행될 수 있는 이유는  코틀린 컴파일러가 이 파일을 컴파일 할 때 새로운 클래스를 정의해준다.

  

  - 코틀린 파일의 모든 최상위 함수는 이 클래스의 정적인 메소드가 된다.

  

  - 최상위 함수가 포함되는 클래스의 이름을 변경하려면 @JvmName 어노테이션을 패키지 이름 선언 이전에 사용하여, 변경할 수 있다.

  

  ```kotlin
  @file:JvmName("StringFunctions")
  
  package strings
  
  fun joinToString(...) : String { ... }
  
  
  /* 자바 */
  import strings.StringFunctions;
  StringFunctions.joinToString(list, ", ", "", "");
  ```

  

  

  

